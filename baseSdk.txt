# Add MiniKit

> Wrap your app with MiniKitProvider and initialize the frame

Add the provider and initialize MiniKit in your main page.

## Add MiniKitProvider

Create `providers/MiniKitProvider.tsx` and wrap `app/layout.tsx`.

```jsx providers/MiniKitProvider.tsx
'use client';
import { MiniKitProvider } from '@coinbase/onchainkit/minikit';
import { ReactNode } from 'react';
import { base } from 'wagmi/chains';

export function MiniKitContextProvider({ children }: { children: ReactNode }) {
  return (
    <MiniKitProvider apiKey={process.env.NEXT_PUBLIC_CDP_CLIENT_API_KEY} chain={base}>
      {children}
    </MiniKitProvider>
  );
}
```

Wrap your root layout:

```jsx app/layout.tsx
import { MiniKitContextProvider } from '@/providers/MiniKitProvider';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang='en'>
      <body>
        <MiniKitContextProvider>{children}</MiniKitContextProvider>
      </body>
    </html>
  );
}
```

## Initialize MiniKit in your page

Use `useMiniKit()` to call `setFrameReady()` when your app is ready.

```jsx app/page.tsx
'use client';
import { useEffect } from 'react';
import { useMiniKit } from '@coinbase/onchainkit/minikit';

export default function HomePage() {
  const { setFrameReady, isFrameReady } = useMiniKit();

  useEffect(() => {
    if (!isFrameReady) setFrameReady();
  }, [isFrameReady, setFrameReady]);

  return <div>Your app content goes here</div>;
}
```

<Tip>
  The provider configures wagmi and react‚Äëquery and uses the Farcaster connector when available.
</Tip>


# Configure Environment

> Add required and optional environment variables for MiniKit

Add required variables to your local and deployment environments.

<Tabs>
  <Tab title="Required Variables">
    These variables are essential for your MiniKit app to function:

    <ParamField path="NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME" type="string" required>
      The name of your Mini App as it appears to users
    </ParamField>

    <ParamField path="NEXT_PUBLIC_URL" type="string" required>
      The deployed URL of your application (must be HTTPS)
    </ParamField>

    <ParamField path="NEXT_PUBLIC_ONCHAINKIT_API_KEY" type="string" required>
      Your Coinbase Developer Platform API key
    </ParamField>

    <ParamField path="FARCASTER_HEADER" type="string" required>
      Generated during manifest creation for account association
    </ParamField>

    <ParamField path="FARCASTER_PAYLOAD" type="string" required>
      Generated during manifest creation for account association
    </ParamField>

    <ParamField path="FARCASTER_SIGNATURE" type="string" required>
      Generated during manifest creation for account association
    </ParamField>
  </Tab>

  <Tab title="Optional Variables">
    These variables enhance your app's appearance and metadata:

    <ParamField path="NEXT_PUBLIC_APP_ICON" type="string">
      URL to your app's icon (recommended: 48x48px PNG)
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_SUBTITLE" type="string">
      Brief subtitle shown in app listings
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_DESCRIPTION" type="string">
      Detailed description of your app's functionality
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_SPLASH_IMAGE" type="string">
      URL to splash screen image shown during app loading
    </ParamField>

    <ParamField path="NEXT_PUBLIC_SPLASH_BACKGROUND_COLOR" type="string">
      Hex color code for splash screen background (e.g., "#000000")
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_PRIMARY_CATEGORY" type="string">
      Primary category for app discovery (e.g., "social", "gaming", "utility")
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_HERO_IMAGE" type="string">
      Hero image URL displayed in cast previews
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_TAGLINE" type="string">
      Short, compelling tagline for your app
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_OG_TITLE" type="string">
      Open Graph title for social sharing
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_OG_DESCRIPTION" type="string">
      Open Graph description for social sharing
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_OG_IMAGE" type="string">
      Open Graph image URL for social media previews
    </ParamField>
  </Tab>
</Tabs>

### Copy-paste .env example

```bash Terminal
# Required
NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME=YourAppName
NEXT_PUBLIC_URL=https://your-app.vercel.app
NEXT_PUBLIC_ONCHAINKIT_API_KEY=your_cdp_client_api_key

# Generated by `npx create-onchain --manifest`
FARCASTER_HEADER=base64_header
FARCASTER_PAYLOAD=base64_payload
FARCASTER_SIGNATURE=hex_signature

# Optional (appearance and metadata)
NEXT_PUBLIC_APP_ICON=https://your-app.vercel.app/icon.png
NEXT_PUBLIC_APP_SUBTITLE=Short subtitle
NEXT_PUBLIC_APP_DESCRIPTION=Describe what your app does
NEXT_PUBLIC_APP_SPLASH_IMAGE=https://your-app.vercel.app/splash.png
NEXT_PUBLIC_SPLASH_BACKGROUND_COLOR=#000000
NEXT_PUBLIC_APP_PRIMARY_CATEGORY=social
NEXT_PUBLIC_APP_HERO_IMAGE=https://your-app.vercel.app/og.png
NEXT_PUBLIC_APP_TAGLINE=Play instantly
NEXT_PUBLIC_APP_OG_TITLE=Your App
NEXT_PUBLIC_APP_OG_DESCRIPTION=Fast, fun, social
NEXT_PUBLIC_APP_OG_IMAGE=https://your-app.vercel.app/og.png
```

<Warning>
  Ensure all referenced assets are publicly accessible via HTTPS.
</Warning>


# Manifest

> Define and configure your Mini App‚Äôs manifest to power search, discovery, and rich embeds in the Base App.

> **What you‚Äôll learn**\
> By the end of this guide, you‚Äôll be able to:
>
> * Define a complete `farcaster.json` manifest that meets Base App requirements.
> * Map each manifest property to its role in search, discovery, and embeds.
> * Validate images, text, and URLs against required constraints.
> * Link your manifest to your domain using `accountAssociation`.
> * Control indexing for staging and production with `noindex`.

## Overview

Your `/.well-known/farcaster.json` file is the manifest for your Mini App. It contains all the metadata Base App uses to:

* Display your app in search results and category listings
* Generate rich, clickable embeds when your app is shared
* Show your app in users‚Äô saved apps for quick access

If the manifest is missing, incomplete, or invalid, your app won‚Äôt appear in Base App discovery features.

## Location

Serve your manifest over HTTPS at:

```bash Terminal
https://your-domain.com/.well-known/farcaster.json
```

<Tip>
  Serve with `Content-Type: application/json` and ensure the file is publicly accessible (no auth).
</Tip>

## How Base App uses Manifest

* **Search indexing**: Your app appears in search after it has been shared at least once. Indexing typically completes in \~10 minutes.
* **Category placement**: `primaryCategory` determines where your app appears in category browsing. `tags` improve cross-surface visibility and filtering.
* **Embeds**: Open Graph fields (`ogTitle`, `ogDescription`, `ogImageUrl`) and `heroImageUrl` power compelling feed previews that drive clicks.
* **Saved apps**: `name` and `iconUrl` appear when users save your Mini App for quick access.

<Warning>
  If your Mini App does not show in search, follow the debugging guide [here](/mini-apps/troubleshooting/common-issues#1-app-discovery--indexing-issues).
</Warning>

## Example manifest

```json farcaster.json
{
  "accountAssociation": {
    "header": "eyJmaWQiOjkxNTIsInR5cGUiOiJjdXN0b2R5Iiwia2V5IjoiMHgwMmVmNzkwRGQ3OTkzQTM1ZkQ4NDdDMDUzRURkQUU5NDBEMDU1NTk2In0",
    "payload": "eyJkb21haW4iOiJhcHAuZXhhbXBsZS5jb20ifQ",
    "signature": "MHgxMGQwZGU4ZGYwZDUwZTdmMGIxN2YxMTU2NDI1MjRmZTY0MTUyZGU4ZGU1MWU0MThiYjU4ZjVmZmQxYjRjNDBiNGVlZTRhNDcwNmVmNjhlMzQ0ZGQ5MDBkYmQyMmNlMmVlZGY5ZGQ0N2JlNWRmNzMwYzUxNjE4OWVjZDJjY2Y0MDFj"
  },
  "baseBuilder": {
    "allowedAddresses": ["0x..."]
  },
  "frame": {
    "version": "1",
    "name": "Example Mini App",
    "homeUrl": "https://ex.co",
    "iconUrl": "https://ex.co/i.png",
    "splashImageUrl": "https://ex.co/l.png",
    "splashBackgroundColor": "#000000",
    "webhookUrl": "https://ex.co/api/webhook",
    "subtitle": "Fast, fun, social",
    "description": "A fast, fun way to challenge friends in real time.",
    "screenshotUrls": [
      "https://ex.co/s1.png",
      "https://ex.co/s2.png",
      "https://ex.co/s3.png"
    ],
    "primaryCategory": "social",
    "tags": ["example", "miniapp", "baseapp"],
    "heroImageUrl": "https://ex.co/og.png",
    "tagline": "Play instantly",
    "ogTitle": "Example Mini App",
    "ogDescription": "Challenge friends in real time.",
    "ogImageUrl": "https://ex.co/og.png",
    "noindex": true
  }
}
```

<Note>
  For a visual mapping of how fields render, see the [Mini App specification reference](/mini-apps/features/search-and-discovery#visual-specifications).
</Note>

## Field reference

### Top-level fields

| Property             | Type   | Required | Description                                                   |
| -------------------- | ------ | -------- | ------------------------------------------------------------- |
| `accountAssociation` | object | Yes      | Proves domain ownership for your Mini App.                    |
| `frame`              | object | Yes      | Contains all metadata used by Base App.                       |
| `baseBuilder`        | object | Yes      | This verifies ownership and connects your Base Build account. |

### `accountAssociation` fields

| Property    | Type   | Required | Description                                 |
| ----------- | ------ | -------- | ------------------------------------------- |
| `header`    | string | Yes      | Encoded header for the association payload. |
| `payload`   | string | Yes      | Encoded payload containing your domain.     |
| `signature` | string | Yes      | Signature over the payload.                 |

### `baseBuilder` fields

| Property           | Type   | Required | Description                                                   |
| ------------------ | ------ | -------- | ------------------------------------------------------------- |
| `allowedAddresses` | string | Yes      | This verifies ownership and connects your Base Build account. |

### `frame` fields

#### Identity & Launch

Defines your Mini App‚Äôs core identity and the URL users land on when they open it.

| Property  | Type   | Required | Description         | Constraints                                                   |
| --------- | ------ | -------- | ------------------- | ------------------------------------------------------------- |
| `version` | string | Yes      | Manifest version.   | Must be `"1"`.                                                |
| `name`    | string | Yes      | Mini App name.      | Max 32 chars.                                                 |
| `homeUrl` | string | Yes      | Default launch URL. | HTTPS URL, max 1024 chars.                                    |
| `iconUrl` | string | Yes      | Icon image URL.     | HTTPS URL, PNG 1024√ó1024; transparent background discouraged. |

***

#### Loading Experience

Controls the splash screen visuals and colors shown while your Mini App loads.

| Property                | Type   | Required | Description               | Constraints                       |
| ----------------------- | ------ | -------- | ------------------------- | --------------------------------- |
| `splashImageUrl`        | string | Yes      | Loading image.            | HTTPS URL, recommended 200√ó200px. |
| `splashBackgroundColor` | string | Yes      | Loading background color. | Hex code (e.g., `#000000`).       |

***

#### Discovery & Search

Determines how your Mini App is indexed, categorized, and surfaced across Base App discovery features.

| Property          | Type      | Required | Description                                           | Constraints                                                                                                                                                                              |
| ----------------- | --------- | -------- | ----------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `primaryCategory` | string    | Yes      | Controls where your app appears in category browsing. | One of: `games`, `social`, `finance`, `utility`, `productivity`, `health-fitness`, `news-media`, `music`, `shopping`, `education`, `developer-tools`, `entertainment`, `art-creativity`. |
| `tags`            | string\[] | Yes      | Search/filter tags.                                   | Up to 5; ‚â§ 20 chars each; lowercase; no spaces/emojis/special chars.                                                                                                                     |
| `noindex`         | boolean   | No       | Exclude from search results.                          | `true` = exclude, default = include.                                                                                                                                                     |
| `requiredChains`  | string\[] | No       | CAIP-2 chain IDs.                                     | Supported: `eip155:8453` (Base mainnet), `eip155:84532` (Base Sepolia).                                                                                                                  |

***

#### Display Information

Provides the descriptive text, screenshots, and promotional images shown on your Mini App‚Äôs profile.

| Property         | Type      | Required | Description                   | Constraints                                |
| ---------------- | --------- | -------- | ----------------------------- | ------------------------------------------ |
| `subtitle`       | string    | No       | Short description under name. | Max 30 chars; avoid emojis/special chars.  |
| `description`    | string    | No       | Promo text for app page.      | Max 170 chars; avoid emojis/special chars. |
| `tagline`        | string    | No       | Marketing tagline.            | Max 30 chars.                              |
| `heroImageUrl`   | string    | No       | Large promo image.            | 1200√ó630px (1.91:1), PNG/JPG.              |
| `screenshotUrls` | string\[] | No       | Visual previews.              | Max 3; portrait 1284√ó2778px recommended.   |

***

#### Embeds & Social Sharing

Configures how your Mini App appears when shared in feeds or on social platforms.

| Property                   | Type   | Required | Description                | Constraints                       |
| -------------------------- | ------ | -------- | -------------------------- | --------------------------------- |
| `ogTitle`                  | string | No       | Open Graph title.          | Max 30 chars.                     |
| `ogDescription`            | string | No       | Open Graph description.    | Max 100 chars.                    |
| `ogImageUrl`               | string | No       | Open Graph image.          | 1200√ó630px (1.91:1), PNG/JPG.     |
| `imageUrl` (deprecated)    | string | No       | Legacy default feed image. | Prefer `ogImageUrl`.              |
| `buttonTitle` (deprecated) | string | No       | Legacy feed button text.   | Prefer embed button config in OG. |

***

#### Advanced Capabilities

Specifies technical integrations, event handling, and special permissions your Mini App requires.

| Property     | Type   | Required | Description           | Constraints                                                 |
| ------------ | ------ | -------- | --------------------- | ----------------------------------------------------------- |
| `webhookUrl` | string | No       | POST events endpoint. | HTTPS URL, max 1024 chars. Required if using notifications. |

<Warning>
  Choose your `primaryCategory` carefully ‚Äî it determines where your app appears in Base App‚Äôs category browsing and rankings.
</Warning>

## Validation checklist

* Manifest is served over HTTPS at `/.well-known/farcaster.json`
* All required fields are present
* Image sizes match the constraints (icon, OG, hero, screenshots)
* Text fields respect character and formatting limits
* `"noindex": true` is used only for staging/development

<Tip>
  Test your manifest with a simple `curl` to confirm accessibility and headers: `curl -sI https://your-domain.com/.well-known/farcaster.json`.
</Tip>

## Development vs. production

* Set `"noindex": true` for development or staging environments to prevent search indexing.
* Remove or set `"noindex": false` for production so users can discover your app.

<Note>
  Your app appears in search after the first share is detected. Indexing usually completes in \~10 minutes.
</Note>

## Common issues

* Missing required fields ‚Üí app won‚Äôt index in search
* Image format/size mismatches ‚Üí broken or distorted embeds
* Invalid `primaryCategory` ‚Üí app won‚Äôt appear in category browsing
* Overlong strings ‚Üí truncation or rejection at indexing
* Manifest not publicly accessible ‚Üí discovery fails

## Next steps

* Review discovery mechanics and ranking in [Mini App Search and Discovery](/mini-apps/features/search-and-discovery)
* Learn how embeds are generated and tested in [Sharing Your Mini App](/mini-apps/features/embeds-and-previews)


# Optimize Onboarding

> Reduce friction with wallet‚Äëoptional flows and clear value moments

Optimize your onboarding flow to increase user engagement and retention. This guide outlines the best practices that will keep your users in-app and engaged.

### Overview

Deliver value instantly and avoid blocking actions.

* Make the first interaction instant and non-blocking
* Authenticate only when required for security purposes and defer prompts until necessary
* Prefer the built-in Base Account; only offer connect/switch for alternate wallets, never gating
* Use progressive disclosure tied to intent (buy, post, personalize)
* Keep users in-app with [SDK actions for links](/mini-apps/features/links); avoid fragile static urls

### Recommended onboarding flow

<Steps>
  <Step title="First render">
    * Show immediate value (demo content, sample state, or read-only mode)
    * Personalize instantly with [`context`](/mini-apps/technical-reference/minikit/provider-and-initialization) of the user's profile to instantly personalize
    * Display one clear CTA that leads to a meaningful action (e.g. "Post a message", "Buy a token", "Follow a user")
  </Step>

  <Step title="User initiates a protected action">
    * Trigger Sign In with Farcaster (SIWF) / Quick Auth only when needed per [Authentication](/mini-apps/features/Authentication)
    * For onchain actions, use the Base Account automatically. Eliminate explicit wallet connect flows
    * Alternate wallets: offer a non-blocking connect/switch option without gating exploration
  </Step>

  <Step title="Celebrate and amplify">
    * After success, prompt social actions via [SDK actions](/mini-apps/features/links) and [Sharing & Social Graph](/mini-apps/features/sharing-and-social-graph)
    * Offer next step: save, follow, or share ‚Äî optimize with [Search & Discovery](/mini-apps/features/search-and-discovery)
  </Step>
</Steps>

### UX patterns that work

<Tip>
  * Progressive prompts: ask only when needed (buy, post, personalize)
  * Clear copy: explain why you‚Äôre asking ("Sign in to save your score")
</Tip>

* One-time deep link (Connect Account users): if SIWF requires a one-time Farcaster link to register auth address, message it as a quick, one-time setup and return the user seamlessly
* Friendly fallbacks: if auth is skipped or fails, allow continued browsing in read-only mode

### Authentication and wallet guidance

#### Authentication

* Only when your backend needs a verified user
* Use SIWF/Quick Auth to issue a session (JWT) when required

<Warning>
  Do not treat Mini App context as primary auth (it can be spoofed)
</Warning>

Read more in [Authentication](/mini-apps/features/Authentication).

#### Wallets

* Base App provides an in-app Base Account. This should be the default wallet used by your app to streamline interactions.
* Do not show a connect button on first load
* If you support other wallets, show connect/switch as optional and non-blocking
* Use the OnchainKit Wallet component or Wagmi hooks as needed

### Do not use raw deeplinks

<Warning>
  * Always use official SDK actions for cross-client compatibility (e.g., compose cast, view profile)
  * This prevents dead ends and ensures consistent behavior across hosts
</Warning>

Learn how to implement them with [SDK actions](/mini-apps/features/links).

### Measure activation and iterate

<Info>
  * Define activation as the first successful protected action (e.g., first post, first onchain action)
  * Track funnel: first render ‚Üí intent click ‚Üí auth/wallet prompt ‚Üí success ‚Üí share/save
</Info>

* Break down Create Account vs Connect Account behavior to spot friction
* See: Base Build Analytics (coming soon)

### Implementation checklist

<Check>
  * Landing screen is usable without auth or wallet prompts
  * Trigger SIWF/Quick Auth only when backend needs it
</Check>

* Use MiniKit context for analytics only; avoid using it as primary auth
* Use Base Account seamlessly for onchain actions; no upfront connect flow
* If supporting alternate wallets, provide optional, non-blocking connect/switch
* Use SDK actions for social flows (compose/view) instead of deeplinks
* Provide a post-success share step and clear next action
* Test both Create Account and Connect Account paths

### Further reading

<CardGroup cols={3}>
  <Card title="Authentication" icon="key" href="/mini-apps/features/Authentication" />

  <Card title="Links & SDK Actions" icon="link" href="/mini-apps/features/links" />

  <Card title="Search & Discovery" icon="magnifying-glass" href="/mini-apps/features/search-and-discovery" />
</CardGroup>

<CardGroup cols={3}>
  <Card title="Sharing & Social Graph" icon="share" href="/mini-apps/features/sharing-and-social-graph" />

  <Card title="Provider & Initialization" icon="cog" href="/mini-apps/technical-reference/minikit/provider-and-initialization" />

  <Card title="useAuthenticate" icon="book-open" href="/mini-apps/technical-reference/minikit/hooks/useAuthenticate" />
</CardGroup>


# Authentication

> Let users start fast and ask for a wallet only when needed

## Authentication guidance from Base App

<Warning>
  Save authentication that requires an interaction for interactions that require it (e.g., buying something, viewing personalized pages).
</Warning>

Supported approaches:

<Tabs>
  <Tab title="Sign In with Farcaster / Quick Auth">
    Base App natively supports SIWF in-app, enabling social identity without leaving the app. Quick Auth can issue a JWT to persist session state.

    **User Experience in Base App:**

    * **Create Account Users** (new Farcaster accounts created during Base App onboarding): Users see a "Login request" tray with the SIWF message and can sign it directly with their passkey
    * **Connect Account Users** (existing Farcaster accounts connected during onboarding): Users are prompted to deeplink to Farcaster one-time only to register their wallet as an auth address, then enjoy seamless in-app sign-in thereafter
  </Tab>

  <Tab title="Wallet Auth">
    Base App provides an in‚Äëapp smart wallet that doesn't require app switching. Use wallet auth for a persisted session when necessary, but avoid gating initial exploration behind connect.
  </Tab>

  <Tab title="Context Data">
    All hosts return context data (including user). Use it for analytics or lightweight session hints, but **do not treat as primary auth** since context data can be spoofed by developers who create their own mini app hosts.
  </Tab>
</Tabs>

## Implementation Example

```tsx App.tsx
import { useMiniKit, useAuthenticate } from '@coinbase/onchainkit/minikit';

function MyComponent() {
  const { context } = useMiniKit();
  const { user } = useAuthenticate();

  // ‚úÖ Safe: Use context for analytics only
  const userFid = context.user.fid; // For analytics tracking
  
  // ‚úÖ Safe: Use cryptographic verification for auth
  const verifiedUser = user; // From SIWF or wallet auth
  
  // ‚ùå Unsafe: Don't rely on context for primary auth
  // const isAuthenticated = !!context.user.fid; // Can be spoofed!
  
  return (
    <div>
      {/* Use verified user data for secure operations */}
    </div>
  );
}
```

<Info>
  For a complete example of using Quick Auth with MiniKit, see [here](https://github.com/coinbase/onchainkit/blob/main/examples/minikit-example/app/components/UserInfo.tsx).
</Info>

## Best practices

* Gate wallet only at the point of onchain action
* Prefer SIWF/Quick Auth for low‚Äëfriction identity
* Use context for analytics; avoid using it as primary auth
* Handle Base App's different authentication flows gracefully
* Always use cryptographic verification for security-critical operations

Further reading:

<CardGroup cols={2}>
  <Card title="useAuthenticate" icon="book-open" href="/mini-apps/technical-reference/minikit/hooks/useAuthenticate" />

  <Card title="Provider & Initialization" icon="cog" href="/mini-apps/technical-reference/minikit/provider-and-initialization" />
</CardGroup>


# Understanding Mini App Context

> Leverage context data to build social-first mini applications that adapt to user entry points and drive viral growth

Context is the environmental data that is automatically provided to your mini app which describes how, where, and by whom your mini app was launched. This guide shows you how to leverage context to create personalized experiences and optimize viral growth.

## What is Context?

Context provides three essential data objects that shape your user experience:

<CardGroup cols={3}>
  <Card title="User Information" icon="user">
    Profile data of the person using your app
  </Card>

  <Card title="Client Details" icon="mobile">
    Information about the host platform and device
  </Card>

  <Card title="Location Context" icon="map-pin">
    How the user discovered and launched your app
  </Card>
</CardGroup>

<Warning>
  **Context is only available within a Farcaster client such as the Base App, not on the web.**
  If your mini app is accessed via a standard web browser, context data will not be provided. Design your app to gracefully handle the absence of context when running outside the Base App environment.
</Warning>

## Why Context Matters

Context enables you to create mini apps that feel native to their social environment and optimize for viral growth:

| Use Case                | Benefit                                                    |
| ----------------------- | ---------------------------------------------------------- |
| **Personalized UX**     | Customize interface based on user identity and entry point |
| **Viral Optimization**  | Track and optimize discovery paths for growth              |
| **Platform Adaptation** | Adjust functionality for different host platforms          |
| **Social Engagement**   | Leverage social context for community features             |

## Core Context Structure

### User Object

Contains profile information about the person using your mini app:

```typescript User Object Structure
{
  "user": {
    "fid": 20390,
    "username": "sohey", 
    "displayName": "Soheybuildson.base",
    "pfpUrl": "https://imagedelivery.net/BXluQx4ige9GuW0Ia56BHw/..."
  }
}
```

<AccordionGroup>
  <Accordion title="User Object Properties">
    * **fid**: Unique Farcaster identifier for the user
    * **username**: Handle without @ symbol
    * **displayName**: User's chosen display name
    * **pfpUrl**: Profile picture URL
  </Accordion>
</AccordionGroup>

### Client Object

Information about the host platform and device:

```typescript Client Object Structure
{
  "client": {
    "clientFid": 309857,        // Base app identifier
    "added": false,             // App save status
    "platformType": "mobile",   // Device type
    "safeAreaInsets": {
      "top": 0,
      "bottom": 34,
      "left": 0, 
      "right": 0
    }
  }
}
```

<AccordionGroup>
  <Accordion title="Client Object Properties">
    * **clientFid**: Identifies the host app (309857 = Base app)
    * **added**: Whether user has saved your mini app
    * **platformType**: Device type for responsive design
    * **safeAreaInsets**: Safe zones to avoid system UI overlap
  </Accordion>
</AccordionGroup>

### Location Object

Describes how the user discovered your mini app - critical for viral optimization:

<Tabs>
  <Tab title="Launcher Entry">
    ```typescript
    {
      "location": {
        "type": "launcher"
      }
    }
    ```

    <Info>
      **User Journey**: Returning user opening from saved apps\
      **Strategy**: Focus on retention and progression features
    </Info>
  </Tab>

  <Tab title="Messaging Entry">
    ```typescript
    {
      "location": {
        "type": "messaging"
      }
    }
    ```

    <Info>
      **User Journey**: Discovery through private messages\
      **Strategy**: Encourage broader social sharing
    </Info>
  </Tab>

  <Tab title="Cast Embed Entry">
    ```typescript
    {
      "location": {
        "type": "cast_embed",
        "embed": "https://frames-v2-demo-lilac.vercel.app/",
        "cast": {
          "author": {
            "fid": 20390,
            "username": "sohey",
            "displayName": "Soheybuildson.base", 
            "pfpUrl": "https://imagedelivery.net/..."
          },
          "fid": 20390,
          "hash": "0x96178d931158cebbdad1b647b6549f0bb05709ed",
          "timestamp": 1755781905000,
          "text": "Check out this mini app!",
          "embeds": ["https://frames-v2-demo-lilac.vercel.app/"]
        }
      }
    }
    ```

    <Info>
      **User Journey**: Primary viral discovery through social feeds\
      **Strategy**: Optimize first-time experience and immediate engagement
    </Info>
  </Tab>
</Tabs>

## Implementation Guide

<Steps>
  <Step title="Access Context Data">
    Import and use the `useMiniKit()` hook to access context:

    ```typescript
    'use client';
    import { useMiniKit, useIsInMiniApp } from '@coinbase/onchainkit/minikit';
    import { useEffect } from 'react';

    function MyMiniApp() {
      const { context, isFrameReady, setFrameReady } = useMiniKit();

      const { isInMiniApp } = useIsInMiniApp();
      
      useEffect(() => {
        if (!isFrameReady) {
          setFrameReady();
        }
      }, [setFrameReady, isFrameReady]);
      
      // Always check for context availability
      if (isInMiniApp && !context) {
        return <div>Loading...</div>;
      }
      
      // Access context data
      const user = context.user;
      const client = context.client;
      const location = context.location;
      
      return <AppContent />;
    }
    ```

    <Warning>
      Always check for context availability before accessing its properties to avoid runtime errors.
    </Warning>
  </Step>

  <Step title="Create Context-Driven Experiences">
    Design different experiences based on entry point:

    ```typescript
    'use client';
    import { useMiniKit } from '@coinbase/onchainkit/minikit';
    import { useEffect } from 'react';

    function ContextAwareApp() {
      const { context, isFrameReady, setFrameReady } = useMiniKit();
      
      useEffect(() => {
        if (!isFrameReady) {
          setFrameReady();
        }
      }, [setFrameReady, isFrameReady]);
      
      if (!context) return <div>Loading...</div>;
      
      switch (context.location?.type) {
        case 'cast_embed':
          return <ViralOnboarding castAuthor={context.location.cast.author} />;
        case 'launcher': 
          return <ReturningUserDashboard />;
        case 'messaging':
          return <PrivateShareExperience />;
        default:
          return <DefaultExperience />;
      }
    }
    ```

    <Check>
      This approach ensures users get personalized experiences based on how they discovered your app.
    </Check>
  </Step>

  <Step title="Implement Safe Area Support">
    Ensure your UI doesn't overlap with system elements:

    ```typescript
    'use client';
    import { useMiniKit } from '@coinbase/onchainkit/minikit';

    function ResponsiveLayout({ children }) {
      const { context } = useMiniKit();
      const insets = context?.client?.safeAreaInsets;
      
      return (
        <div 
          className="app-container"
          style={{
            paddingTop: insets?.top || 0,
            paddingBottom: insets?.bottom || 0,
            paddingLeft: insets?.left || 0,
            paddingRight: insets?.right || 0,
          }}
        >
          {children}
        </div>
      );
    }
    ```

    <Tip>
      Safe area implementation is crucial for mobile experiences to avoid system UI overlap.
    </Tip>
  </Step>

  <Step title="Add Social Features">
    Leverage cast embed data for social engagement:

    ```typescript
    import { useComposeCast, useViewProfile } from '@coinbase/onchainkit/minikit';

    function SocialAcknowledgment() {
      const { context } = useMiniKit();
      const { composeCast } = useComposeCast();
      const viewProfile = useViewProfile();
      
      if (context?.location?.type !== 'cast_embed') {
        return null;
      }
      
      const { author, text, timestamp,hash } = context.location.cast;
      
      const handleThankSharer = () => {
        composeCast({
          text: `Thanks @${author.username} for sharing this awesome mini app! üôè`,
          // Optionally include the original cast as parent
          parent: {
            type: 'cast',
            hash: hash
          }
        });
      };
      
      const handleViewProfile = () => {
        viewProfile(author.fid);
      };
      
      return (
        <div className="social-credit">
          <img src={author.pfpUrl} alt={author.displayName} />
          <div>
            <p><strong>@{author.username}</strong> shared this app</p>
            <p>"{text}"</p>
            <div className="action-buttons">
              <button onClick={handleThankSharer}>
                Thank them! üôè
              </button>
              <button onClick={handleViewProfile}>
                View Profile
              </button>
            </div>
          </div>
        </div>
      );
    }
    ```
  </Step>
</Steps>

## Analytics and Growth Tracking

<Note>
  **Leverage** [Base.dev](https://www.base.dev/) provides comprehensive analytics out-of-the-box including user engagement metrics, entry point analysis, and session tracking. Import your mini app to Base.dev to access real-time analytics that complement your context-driven insights.
</Note>

### Viral Attribution

Track how users discover your app to optimize growth:

```typescript Analytics Implementation
function trackDiscovery() {
  const { context } = useMiniKit();
  
  const discoveryData = {
    type: context?.location?.type,
    platform: context?.client?.platformType,
    userAdded: context?.client?.added,
  };
  
  if (context?.location?.type === 'cast_embed') {
    discoveryData.sharedBy = context.location.cast.author.username;
    discoveryData.castHash = context.location.cast.hash;
  }
  
  analytics.track('mini_app_launch', discoveryData);
}
```

### Growth Metrics to Monitor

| Metric                   | Context Source                   | Optimization Goal           |
| ------------------------ | -------------------------------- | --------------------------- |
| **Cast Embed Launches**  | `location.type === 'cast_embed'` | Maximize viral sharing      |
| **Return User Rate**     | `location.type === 'launcher'`   | Improve retention           |
| **Share Attribution**    | `cast.author` data               | Identify top advocates      |
| **Platform Performance** | `client.platformType`            | Optimize for mobile/desktop |

## Next Steps

<Tip>
  Understanding and leveraging context is foundational to creating mini apps that feel native to their social environment and drive sustainable viral growth.
</Tip>

<CardGroup cols={2}>
  <Card title="Implement Context Access" icon="code">
    Add `useMiniKit()` to your main component and validate context data
  </Card>

  <Card title="Create Entry Point Flows" icon="flow-chart">
    Design different experiences for each location type
  </Card>

  <Card title="Add Safe Area Support" icon="mobile">
    Implement responsive padding for mobile experiences
  </Card>

  <Card title="Track Viral Metrics" icon="chart-line">
    Set up analytics for growth measurement and optimization
  </Card>
</CardGroup>


# Sharing & Social Graph

> Enable native share flows and social navigation

## Adding Share Functionality

Prompt users to share during key accomplishment moments using MiniKit‚Äôs compose hook.

```ts ComposeCastButton.tsx
import { useComposeCast } from '@coinbase/onchainkit/minikit';

export default function ComposeCastButton() {
  const { composeCast } = useComposeCast();

  const handleCompose = () => {
    composeCast({ text: 'Just minted an awesome NFT using @coinbase OnchainKit!' });
  };

  const handleComposeWithEmbed = () => {
    composeCast({
      text: 'Check out this amazing Mini App!',
      embeds: ['https://your-mini-app-url.com'],
    });
  };

  return (
    <div>
      <button onClick={handleCompose}>Share Achievement</button>
      <button onClick={handleComposeWithEmbed}>Share Frame</button>
    </div>
  );
}
```

<Tip>
  Strategic sharing moments include: post‚Äëachievement, post‚Äëmint, after beating a challenge, or reaching milestones.
</Tip>

## View Casts and Profiles

Link users into casts and profiles directly from your app via MiniKit hooks.

<CardGroup cols={2}>
  <Card title="useViewCast" icon="book-open" href="/mini-apps/technical-reference/minikit/hooks/useViewCast" />

  <Card title="useViewProfile" icon="book-open" href="/mini-apps/technical-reference/minikit/hooks/useViewProfile" />
</CardGroup>

## Best Practices

* Encourage meaningful, contextual shares
* Avoid spammy prompts; tie sharing to value
* Make shared previews visually consistent with your UI

Further reading:

* [Embeds & Previews](/mini-apps/features/embeds-and-previews)


# Wallet

> Learn how Base Accounts enhance Mini App user experience and what Mini App developers need to know to implement Base Account capabilities.

> **What you'll learn**\
> By the end of this guide, you'll understand:
>
> * How to handle wallet transactions effectively in Mini Apps, including leveraging enhanced Base Account capabilities when available.

## Default Wallets in Mini Apps

Mini Apps launched within the Base App are automatically connected to the user's [Base Account](/base-account/overview), eliminating wallet connection flows and enabling instant onchain interactions. This zero-friction approach means users can immediately swap, send, and transact without any wallet setup, maintaining a familiar experience with their existing Base Account and assets.

## For Mini App Development

<Steps>
  <Step title="Detect Base Account Capabilities">
    Base Accounts offer enhanced features that traditional wallets don't support.

    * Use `wallet_getCapabilities` to check for `atomicBatch`, `paymasterService`, and `auxiliaryFunds`
    * Adapt your UI to show streamlined workflows for Base Account users
    * Provide fallback experiences for traditional wallets

    <Check>
      Test with both Base Accounts and traditional wallets to ensure your capability detection works correctly.
    </Check>

    Learn More: [Base Account Capabilities Overview](/base-account/reference/core/capabilities/overview)
  </Step>

  <Step title="Implement Sponsored Gas Transactions">
    Enable sponsored gas transactions where your Mini App pays gas fees for users.

    * Check for `paymasterService` capability before offering gas-free transactions
    * Use the `capabilities` parameter in `writeContracts` to enable sponsored gas
    * Handle cases where paymaster service is unavailable

    <Check>
      Verify your Mini App works with Base Accounts that have zero ETH balance.
    </Check>

    Learn More: [Paymaster Service](/base-account/reference/core/capabilities/paymasterService)
  </Step>

  <Step title="Optimize Transaction Patterns">
    Base Accounts can batch multiple operations into single transactions.

    * Use `atomicBatch` capability to group related transactions
    * Implement `wallet_sendCalls` for complex workflows
    * Show one confirmation instead of multiple prompts

    <Tip>
      Consider transaction batching for multi-step operations like approve + transfer + mint.
    </Tip>

    Learn More: [Batch Transactions Guide](/base-account/improve-ux/batch-transactions)
  </Step>
</Steps>

## Base Account Benefits for Mini Apps

| Feature                | What It Does                                   | Mini App Benefit                                        |
| ---------------------- | ---------------------------------------------- | ------------------------------------------------------- |
| Atomic Batch           | Combines multiple transactions into one        | Multi-step workflows require only one user confirmation |
| Paymaster Service      | App pays gas fees, not user                    | Users can transact without owning ETH                   |
| Passkey Authentication | Uses device biometrics instead of private keys | Faster, more secure user authentication                 |

## Implementation Examples

### Capability Detection

```javascript
function useBaseAccountCapabilities(address) {
  const [capabilities, setCapabilities] = useState({});
  
  useEffect(() => {
    async function detect() {
      const caps = await publicClient.request({
        method: 'wallet_getCapabilities',
        params: [address]
      });
      
      setCapabilities({
        atomicBatch: caps['0x2105']?.atomicBatch?.supported,
        paymasterService: caps['0x2105']?.paymasterService?.supported,
        auxiliaryFunds: caps['0x2105']?.auxiliaryFunds?.supported
      });
    }
    
    if (address) detect();
  }, [address]);
  
  return capabilities;
}
```

### Sponsored Gas Implementation

```javascript
import { useCapabilities, useWriteContracts } from 'wagmi/experimental'

function SponsoredTransactionButton() {
  const account = useAccount()
  const { writeContracts } = useWriteContracts()
  const { data: availableCapabilities } = useCapabilities({
    account: account.address,
  })
  
  const capabilities = useMemo(() => {
    if (!availableCapabilities || !account.chainId) return {}
    const capabilitiesForChain = availableCapabilities[account.chainId]
    if (
      capabilitiesForChain['paymasterService'] &&
      capabilitiesForChain['paymasterService'].supported
    ) {
      return {
        paymasterService: {
          url: `https://api.developer.coinbase.com/rpc/v1/base/v7HqDLjJY4e28qgIDAAN4JNYXnz88mJZ`,
        },
      }
    }
    return {}
  }, [availableCapabilities, account.chainId])

  const handleSponsoredMint = () => {
    writeContracts({
      contracts: [{
        address: '0x...',
        abi: contractAbi,
        functionName: 'mint',
        args: [account.address],
      }],
      capabilities,
    })
  }

  return <button onClick={handleSponsoredMint}>Mint NFT (Gas Free)</button>
}
```

### Capability-Based UI

```javascript
function MiniAppWorkflow() {
  const { address } = useAccount();
  const { atomicBatch } = useBaseAccountCapabilities(address);
  
  if (atomicBatch) {
    // Base Account: One-click workflow
    return <OneClickPurchaseFlow />;
  } else {
    // Traditional wallet: Multi-step workflow  
    return <MultiStepPurchaseFlow />;
  }
}
```

## Additional Resources

For detailed implementation of Base Account features:

<CardGroup cols={3}>
  <Card title="User Authentication" href="https://docs.base.org/base-account/guides/authenticate-users">
    Authenticate Users Guide
  </Card>

  <Card title="Base Pay Guide" href="https://docs.base.org/base-account/guides/accept-payments">
    Base Pay Guide
  </Card>

  <Card title="Sign and Verify Signatures" href="https://docs.base.org/base-account/guides/sign-and-verify-typed-data">
    Sign and Verify Typed Data Guide
  </Card>
</CardGroup>


# Links

> Handle external navigation and URL interactions safely across clients

When building Mini Apps, proper link handling is crucial for providing a consistent user experience across different clients. This guide outlines best practices for external navigation and URL interactions.

## Core Principles

### Use SDK Actions for Cross-Client Compatibility

**Always use official SDK functions instead of static URLs.** Static URLs can break cross-client compatibility and may leave users unable to complete actions in your Mini App.

<Warning>
  Avoid using direct HTML links (`<a href="">`, `<Link href="">`) or static URLs in your Mini App. These approaches don't work consistently across different clients and can create poor user experiences.
</Warning>

## External Navigation

### Opening External URLs

Use `sdk.actions.openUrl()` to safely open external websites in the client's in-app browser:

```typescript App.tsx
import { sdk } from '@@farcaster/miniapp-sdk';

// Correct: Use SDK action
const openExternalSite = () => {
  sdk.actions.openUrl('https://example.com');
};

// Incorrect: Direct HTML link
// <a href="https://example.com">Visit Site</a>
```

### Composing Casts

Use `sdk.actions.composeCast()` instead of composer intent URLs:

```typescript App.tsx
import { sdk } from '@farcaster/miniapp-sdk';

// Correct: Use SDK action
const shareContent = () => {
  sdk.actions.composeCast({
    text: 'Check out this Mini App!',
    embeds: ['https://yourminiapp.com']
  });
};

// Incorrect: Composer intent URLs
// window.open('https://farcaster.com/~/compose?text=...')
```

## Best Practices

### 1. Prioritize SDK Actions

Before implementing any navigation or linking functionality:

1. Check if an official SDK action exists for your use case
2. Use the SDK action instead of crafting custom URLs
3. Test across multiple clients to ensure compatibility

### 2. Handle Unsupported Features Gracefully

When using features that may not be supported in all clients:

```javascript App.tsx
import { sdk } from '@@farcaster/miniapp-sdk';

const handleExternalLink = (url) => {
  try {
    sdk.actions.openUrl(url);
  } catch (error) {
    // Fallback behavior for unsupported clients
    console.log('External navigation not supported');
  }
};
```

### 3. Avoid Client-Specific URLs

Don't hardcode URLs specific to particular clients (like Warpcast URLs). Instead, use SDK actions that work across all supported clients.

## Common Patterns

### Navigation Buttons

```javascript NavigationComponent.tsx
import { sdk } from '@@farcaster/miniapp-sdk';

const NavigationComponent = () => {
  const handleExternalLink = () => {
    sdk.actions.openUrl('https://docs.example.com');
  };

  const handleShare = () => {
    sdk.actions.composeCast({
      text: 'Just used this amazing Mini App!',
      embeds: [window.location.href]
    });
  };

  return (
    <div>
      <button onClick={handleExternalLink}>
        View Documentation
      </button>
      <button onClick={handleShare}>
        Share This App
      </button>
    </div>
  );
};
```

### Conditional Navigation

```javascript ConditionalNavigation.tsx
import { sdk } from '@@farcaster/miniapp-sdk';

const ConditionalNavigation = () => {
  const context = sdk.context;
  
  const handleNavigation = () => {
    // Adapt behavior based on client capabilities
    if (context.client.clientFid) {
      sdk.actions.openUrl('https://app-specific-url.com');
    } else {
      // Fallback for other clients
      window.open('https://fallback-url.com', '_blank');
    }
  };

  return (
    <button onClick={handleNavigation}>
      Open External Resource
    </button>
  );
};
```

## Migration Guide

If your Mini App currently uses static URLs or direct links, update them using these patterns:

| Current Implementation                                    | Recommended SDK Action                                    |
| --------------------------------------------------------- | --------------------------------------------------------- |
| `<a href="https://external.com">`                         | `sdk.actions.openUrl('https://external.com')`             |
| `window.open('https://farcaster.com/~/compose?text=...')` | `sdk.actions.composeCast({ text: '...', embeds: [...] })` |
| Farcaster-specific deeplinks                              | Use appropriate SDK action                                |
| Direct profile links                                      | Use SDK actions for profile navigation when available     |

## Future Considerations

While deeplinks are not currently supported, they are on the roadmap. When they become available, this documentation will be updated with specific implementation guidance. In the meantime, continue using SDK actions for the most reliable cross-client experience.

# Common Issues & Debugging

> Frequent issues encountered during Mini App development and their solutions

## Prerequisites & Setup Verification

Ensure your Mini App has the foundational requirements in place.

### Required Files and Structure

```text
your-domain.com/
‚îú‚îÄ‚îÄ .well-known/
‚îÇ   ‚îî‚îÄ‚îÄ farcaster.json          # Required manifest file
‚îú‚îÄ‚îÄ your-app/
‚îÇ   ‚îú‚îÄ‚îÄ index.html              # Your app entry point
‚îÇ   ‚îî‚îÄ‚îÄ ...                     # Your app files
```

### Environment Setup Checklist

* Domain is accessible via HTTPS
* Manifest file exists at `/.well-known/farcaster.json`
* All image URLs are publicly accessible

### Basic Validation Steps

1. Test manifest accessibility: visit `https://yourdomain.com/.well-known/farcaster.json`
2. Validate JSON syntax with JSONLint
3. Ensure your app loads without console errors

## Quick Diagnostic Workflow

* Not appearing in search? ‚Üí App Discovery & Indexing Issues
* Not rendering as an embed? ‚Üí Embed Rendering Issues
* Wallet connection problems? ‚Üí Wallet Connection Problems
* Need mobile testing tools? ‚Üí Mobile Testing & Debugging
* Changes not appearing? ‚Üí Manifest Configuration Problems
* App closes on gestures? ‚Üí Gesture Conflicts and App Dismissal Issues

## Detailed Problem Solutions

### 1. App Discovery & Indexing Issues

Problem: Your Mini App doesn't appear in search results or app catalogs.

Root cause: Missing or incomplete manifest configuration.

Solution: Ensure your manifest includes all required fields (see Manifest feature guide).

Critical requirements:

* `primaryCategory` is required for searchability and category pages
* `accountAssociation` is required for verification

App Indexing Requirements:

1. Complete your manifest setup
2. Share your Mini App URL in a post
3. Indexing can take up to 10 minutes
4. Verify appearance in app catalogs

Caching Issues ‚Äî Changes Not Appearing:

Farcaster clients may cache manifest data for up to 24 hours. Re‚Äëshare to trigger a refresh and allow \~10 minutes.

### 2. Manifest Configuration Problems

Image Display Issues:

1. Test image accessibility in incognito
2. Verify image format (PNG, JPG, WebP supported)
3. Check dimensions
4. Ensure HTTPS URLs only

### 3. Embed Rendering Issues

Problem: Your Mini App URL doesn't render as a rich embed when shared.

Root cause: Incorrect or missing `fc:frame` metadata.

Solution: Use `name="fc:frame"` meta tag in `<head>` and validate using the Embed Tool.

### 4. Wallet Connection Problems

Always use the user's connected wallet for optimal experience. You can do this either by using [OnchainKit's Wallet component](/onchainkit/wallet/wallet) or Wagmi hooks. Below is a Wagmi hook example:

```tsx App.tsx
import { useAccount } from 'wagmi';

function MyComponent() {
  const { address, isConnected } = useAccount();
  
  const walletConnected = isConnected;
  
  const userAddress = address; // Cryptographically verified
  
  return (
    <div>
      {walletConnected && (
        <p>Wallet: {userAddress}</p>
      )}
      {/* Use wallet data for secure operations */}
    </div>
  );
}
```

### 5. Gesture Conflicts and App Dismissal Issues

Disable native gestures when calling ready if you use swipe/drag interactions:

```ts App.tsx
await sdk.actions.ready({ disableNativeGestures: true });
```

### 6. Mobile Testing & Debugging

**Eruda Mobile Console Setup:**

Add Eruda for mobile console debugging during development:

```tsx App.tsx
import { useEffect } from 'react';

export default function App() {
  useEffect(() => {
    // Only load Eruda in development and not on localhost
    if (typeof window !== 'undefined' && 
        process.env.NODE_ENV === 'development' && 
        !window.location.hostname.includes('localhost')) {
      import('eruda').then((eruda) => eruda.default.init());
    }
  }, []);

  return (
    <div>
      {/* Your app content */}
    </div>
  );
}
```

**Mobile Testing Workflow:**

1. Deploy to production or use ngrok for local testing
2. Share the mini app in a Farcaster DM to yourself
3. Open in mobile client (Base App, Farcaster)
4. Use Eruda console for debugging on mobile
5. Test across multiple clients for compatibility

**Testing Checklist:**

* [ ] App loads correctly on mobile devices
* [ ] Touch interactions work properly
* [ ] Viewport is correctly sized
* [ ] Images load and display correctly
* [ ] Console shows no critical errors

## Advanced Troubleshooting

**CBW Validator Tool:**

Use the Coinbase Wallet validator for Base App compatibility analysis. This AI-powered tool can identify unsupported patterns and suggest improvements.

**Complete Manifest Example:**

```json farcaster.json
{
  "accountAssociation": {
    "header": "your-farcaster-header",
    "payload": "your-farcaster-payload", 
    "signature": "your-farcaster-signature"
  },
    "baseBuilder": {
    "allowedAddresses": ["0x..."]
  },
  "frame": {
    "name": "Your Mini App",
    "iconUrl": "https://yourapp.com/icon.png",
    "homeUrl": "https://yourapp.com",
    "imageUrl": "https://yourapp.com/og.png",
    "buttonTitle": "Launch App", 
    "description": "Your app description under 130 characters",
    "primaryCategory": "social",
    "tags": ["tag1", "tag2"]
  }
}
```

## Success Verification

Basic functionality and discovery/sharing checklists: confirm load, images, wallet, manifest endpoint, embed rendering, and search presence.

## Getting Additional Help

* Mini App Debug Tool
* Mini App Embed Tool
* JSONLint
* Eruda
* Base Discord ‚Äî #minikit channel

# Base App Compatibility

> Which Mini App features are supported in Base App (TBA) today

Base App is working towards full compatibility with the Farcaster Mini App SDK. During beta, some features are not yet supported.

## Currently Unsupported (examples)

* Notifications: not yet supported
* Mini App actions: `.addMiniApp()`, `.requestCameraAndMicrophoneAccess()` (ETA 8/28)

## Base App Client Detection

```tsx App.tsx
import { useMiniKit } from '@coinbase/onchainkit/minikit';

function MyComponent() {
  const { context } = useMiniKit();
  const isBaseApp = context.client.clientFid === 309857;

  if (isBaseApp) {
    // Use Base App-specific features
    console.log('Running in Base App');
  }
  
  return <div>{/* Your component */}</div>;
}
```

## Wallet Interactions

Base App provides multiple wallet integration methods:

### Method 1: OnchainKit (Recommended)

```tsx App.tsx
import { ConnectWallet } from '@coinbase/onchainkit/wallet';

// Base App provides EIP-1193 provider automatically
function WalletConnection() {
  return <ConnectWallet />;
}
```

### Method 2: Wagmi Hooks

```tsx App.tsx
import { useConnect } from 'wagmi';

// Works with Base App's injected provider
function WalletConnect() {
  const { connect, connectors } = useConnect();
  // Base App connector available automatically
}
```

### Method 3: Browser Window Access

```tsx App.tsx
// Direct access to Base App's provider
async function connectWallet() {
  if (window.ethereum) {
    await window.ethereum.request({
      method: 'eth_requestAccounts'
    });
  }
}
```

## Navigation & Links

**Use MiniKit hooks** instead of manual Farcaster deeplinks:

* ‚úÖ `useOpenUrl()` instead of `farcaster://open-url`
* ‚úÖ `useComposeCast()` instead of manual cast composition
* ‚úÖ `useViewProfile()` instead of profile deeplinks

```tsx App.tsx
import { useOpenUrl, useComposeCast } from '@coinbase/onchainkit/minikit';

function Navigation() {
  const openUrl = useOpenUrl();
  const composeCast = useComposeCast();
  
  const handleExternalLink = () => {
    openUrl('https://example.com');
  };
  
  const handleShare = () => {
    composeCast({
      text: "Check this out!",
      embeds: [window.location.href]
    });
  };
}

## Supported Chains

Base, Mainnet, Optimism, Arbitrum, Polygon, Zora, BNB, Avalanche C‚ÄëChain

## Development Notes

- Use `openUrl()` for external navigation
- Use `composeCast()` instead of composer URLs
- Provide alternatives for haptic feedback
- Avoid relying on location context for core flows
- To detect Base App, check `context.client.clientFid` (Base App: `309857`)

We are actively expanding compatibility and will update this page as support increases.



```
# Overview

> The best way to build Mini Apps on Base.

MiniKit is the official SDK for building Mini Apps that work seamlessly across Base App and other Farcaster clients. It provides React hooks, context management, and wallet integration that eliminates the complexity of building social-native applications.

## Why MiniKit?

<CardGroup cols={2}>
  <Card title="Seamless Integration" icon="link">
    Works with OnchainKit for complete onchain app development with shared providers and configuration.
  </Card>

  <Card title="Social-Native" icon="users">
    Built specifically for Farcaster's frame-based architecture with native social features.
  </Card>

  <Card title="Wallet Abstraction" icon="wallet">
    Simplified wallet connections and transaction flows with automatic provider detection.
  </Card>

  <Card title="Cross-Client" icon="mobile">
    Works across Base App, Farcaster, and other clients with consistent behavior.
  </Card>
</CardGroup>

## Architecture

MiniKit consists of three main components:

### MiniKitProvider

React context provider that configures:

* Wagmi and react-query setup
* Chain and API key configuration
* Theme and appearance settings
* Farcaster connector integration

### Hooks

React hooks for frame interactions:

* **Frame Management**: `useMiniKit`, `useAddFrame`, `useClose`
* **Navigation**: `useOpenUrl`, `useViewProfile`, `useViewCast`
* **Social**: `useComposeCast`, `useNotification`
* **Authentication**: `useAuthenticate`
* **UI**: `usePrimaryButton`

### CLI Tools

Command-line utilities for:

* Project scaffolding with `npx create-onchain --mini`
* Manifest generation with `npx create-onchain --manifest`
* Development workflow automation

## Getting Started

<CardGroup cols={2}>
  <Card title="New Project" icon="plus" href="/mini-apps/quickstart/new-apps/install">
    Create a new Mini App from scratch using the CLI scaffolding tool.
  </Card>

  <Card title="Existing App" icon="code" href="/mini-apps/quickstart/existing-apps/install">
    Add MiniKit to your existing Next.js application.
  </Card>
</CardGroup>

## Key Concepts

### Frame Lifecycle

Mini Apps run within Farcaster frames and must signal readiness:

1. **Initialize** MiniKitProvider in your app root
2. **Signal readiness** with `setFrameReady()` in your main component
3. **Handle interactions** through MiniKit hooks

### Context vs Authentication

* **Context data** (`useMiniKit().context`) provides user info but can be spoofed
* **Authentication** (`useAuthenticate()`) provides cryptographically verified user identity
* Always use authentication for security-critical operations

### Cross-Client Compatibility

MiniKit automatically detects the client environment and adapts:

* **Base App**: Native wallet integration, enhanced features
* **Farcaster**: Standard Farcaster protocol compliance
* **Other clients**: Graceful fallbacks and compatibility modes

## Technical Reference

<CardGroup cols={2}>
  <Card title="Provider & Initialization" icon="settings" href="/mini-apps/technical-reference/minikit/provider-and-initialization">
    Configure MiniKitProvider and initialize frame context.
  </Card>

  <Card title="Hooks Reference" icon="code" href="/mini-apps/technical-reference/minikit/hooks/useMiniKit">
    Complete reference for all MiniKit React hooks.
  </Card>
</CardGroup>


# Overview

> The best way to build Mini Apps on Base.

MiniKit is the official SDK for building Mini Apps that work seamlessly across Base App and other Farcaster clients. It provides React hooks, context management, and wallet integration that eliminates the complexity of building social-native applications.

## Why MiniKit?

<CardGroup cols={2}>
  <Card title="Seamless Integration" icon="link">
    Works with OnchainKit for complete onchain app development with shared providers and configuration.
  </Card>

  <Card title="Social-Native" icon="users">
    Built specifically for Farcaster's frame-based architecture with native social features.
  </Card>

  <Card title="Wallet Abstraction" icon="wallet">
    Simplified wallet connections and transaction flows with automatic provider detection.
  </Card>

  <Card title="Cross-Client" icon="mobile">
    Works across Base App, Farcaster, and other clients with consistent behavior.
  </Card>
</CardGroup>

## Architecture

MiniKit consists of three main components:

### MiniKitProvider

React context provider that configures:

* Wagmi and react-query setup
* Chain and API key configuration
* Theme and appearance settings
* Farcaster connector integration

### Hooks

React hooks for frame interactions:

* **Frame Management**: `useMiniKit`, `useAddFrame`, `useClose`
* **Navigation**: `useOpenUrl`, `useViewProfile`, `useViewCast`
* **Social**: `useComposeCast`, `useNotification`
* **Authentication**: `useAuthenticate`
* **UI**: `usePrimaryButton`

### CLI Tools

Command-line utilities for:

* Project scaffolding with `npx create-onchain --mini`
* Manifest generation with `npx create-onchain --manifest`
* Development workflow automation

## Getting Started

<CardGroup cols={2}>
  <Card title="New Project" icon="plus" href="/mini-apps/quickstart/new-apps/install">
    Create a new Mini App from scratch using the CLI scaffolding tool.
  </Card>

  <Card title="Existing App" icon="code" href="/mini-apps/quickstart/existing-apps/install">
    Add MiniKit to your existing Next.js application.
  </Card>
</CardGroup>

## Key Concepts

### Frame Lifecycle

Mini Apps run within Farcaster frames and must signal readiness:

1. **Initialize** MiniKitProvider in your app root
2. **Signal readiness** with `setFrameReady()` in your main component
3. **Handle interactions** through MiniKit hooks

### Context vs Authentication

* **Context data** (`useMiniKit().context`) provides user info but can be spoofed
* **Authentication** (`useAuthenticate()`) provides cryptographically verified user identity
* Always use authentication for security-critical operations

### Cross-Client Compatibility

MiniKit automatically detects the client environment and adapts:

* **Base App**: Native wallet integration, enhanced features
* **Farcaster**: Standard Farcaster protocol compliance
* **Other clients**: Graceful fallbacks and compatibility modes

## Technical Reference

<CardGroup cols={2}>
  <Card title="Provider & Initialization" icon="settings" href="/mini-apps/technical-reference/minikit/provider-and-initialization">
    Configure MiniKitProvider and initialize frame context.
  </Card>

  <Card title="Hooks Reference" icon="code" href="/mini-apps/technical-reference/minikit/hooks/useMiniKit">
    Complete reference for all MiniKit React hooks.
  </Card>
</CardGroup>


# useMiniKit

> Access frame context and control readiness state

Defined in [@coinbase/onchainkit](https://github.com/coinbase/onchainkit)

<Info>
  Primary hook for accessing MiniKit frame context and managing frame readiness. This hook provides essential Mini App state and user context information.
</Info>

## Returns

<ResponseField name="context" type="MiniKitContext">
  Frame context information provided by the host application.

  <Expandable title="MiniKitContext properties">
    <ResponseField name="user" type="object">
      User information from the host application.

      <Expandable title="User properties">
        <ResponseField name="fid" type="string">
          Farcaster ID of the current user. Can be spoofed - use for analytics only.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="client" type="object">
      Information about the host client application.

      <Expandable title="Client properties">
        <ResponseField name="added" type="boolean">
          Whether the user has saved this Mini App to their collection.
        </ResponseField>

        <ResponseField name="clientFid" type="string">
          Farcaster ID of the host client. Base App: "309857".
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="location" type="string">
      Where the Mini App was launched from (e.g., "cast", "launcher", "notification").
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="isFrameReady" type="boolean">
  Whether the frame has signaled readiness to the host application.
</ResponseField>

<ResponseField name="setFrameReady" type="() => void">
  Function to signal frame readiness to the host application. Call this once your Mini App has finished loading.
</ResponseField>

<RequestExample>
  ```tsx app/App.tsx
  'use client';

  import { useMiniKit } from '@coinbase/onchainkit/minikit';
  import { useEffect } from 'react';

  export default function MyMiniApp() {
    const { context, isFrameReady, setFrameReady } = useMiniKit();

    useEffect(() => {
      if (!isFrameReady) {
        setFrameReady();
      }
    }, [setFrameReady, isFrameReady]);

    return (
      <div>
        <h1>Welcome, User {context.user.fid}!</h1>
        <p>Launched from: {context.location}</p>
        {context.client.added && (
          <p>‚úÖ You've saved this app!</p>
        )}
      </div>
    );
  }
  ```

  ```tsx components/ClientSpecificFeatures.tsx
  import { useMiniKit } from '@coinbase/onchainkit/minikit';

  export default function ClientSpecificFeatures() {
    const { context } = useMiniKit();
    
    const isBaseApp = context.client.clientFid === '309857';
    const isFarcaster = context.client.clientFid === '1';

    return (
      <div>
        {isBaseApp && (
          <div>Base App specific features</div>
        )}
        {isFarcaster && (
          <div>Farcaster specific features</div>
        )}
      </div>
    );
  }
  ```

  ```tsx components/AnalyticsTracker.tsx
  import { useMiniKit } from '@coinbase/onchainkit/minikit';
  import { useEffect } from 'react';

  export default function AnalyticsTracker() {
    const { context } = useMiniKit();

    useEffect(() => {
      // ‚úÖ Safe: Use context for analytics
      analytics.track('mini_app_opened', {
        userFid: context.user.fid,
        client: context.client.clientFid,
        launchLocation: context.location,
        hasAddedApp: context.client.added
      });
    }, [context]);

    return <div>App content...</div>;
  }
  ```
</RequestExample>

## Usage Notes

### Frame Readiness

Always call `setFrameReady()` once your Mini App has finished initial loading:

```tsx components/FrameReady.tsx
useEffect(() => {
  if (!isFrameReady) {
    setFrameReady();
  }
}, [setFrameReady, isFrameReady]);
```

### Context Data Security

<Warning>
  Context data can be spoofed by malicious actors. Never use context data for authentication or security-critical operations. Use `useAuthenticate` for verified user identity.
</Warning>

```tsx
// ‚ùå Don't use for authentication
const isAuthenticated = !!context.user.fid; // Can be spoofed!

// ‚úÖ Use for analytics and UX hints only
const userHint = context.user.fid; // For analytics tracking
```

### Client Detection

Use client detection to provide platform-specific experiences:

```tsx components/ClientDetection.tsx
const isBaseApp = context.client.clientFid === '309857';
const isFarcaster = context.client.clientFid === '1';

if (isBaseApp) {
  // Enable Base App specific features
}
```

<Info>
  The `useMiniKit` hook must be used within a component that's wrapped by `MiniKitProvider`. This hook provides the foundation for all Mini App functionality and should be one of the first hooks you use in your application.
</Info>


# useAuthenticate

> Cryptographically authenticate users with Sign In with Farcaster

Defined in [@coinbase/onchainkit](https://github.com/coinbase/onchainkit)

<Info>
  Provides cryptographically secure user authentication using Sign In with Farcaster (SIWF). Returns verified user identity and signature for secure operations.
</Info>

## Returns

<ResponseField name="user" type="AuthenticatedUser | null">
  Authenticated user object with verified identity, or null if not authenticated.

  <Expandable title="AuthenticatedUser properties">
    <ResponseField name="fid" type="string">
      Verified Farcaster ID of the authenticated user.
    </ResponseField>

    <ResponseField name="signature" type="string">
      Cryptographic signature proving user identity.
    </ResponseField>

    <ResponseField name="message" type="string">
      The signed message used for authentication.
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="authenticate" type="() => Promise<AuthenticatedUser | null>">
  Function to trigger the authentication flow. Returns verified user data on success.
</ResponseField>

<RequestExample>
  ```tsx components/AuthButton.tsx
  import { useAuthenticate } from '@coinbase/onchainkit/minikit';
  import { useState } from 'react';

  export default function AuthButton() {
    const { user, authenticate } = useAuthenticate();
    const [isAuthenticating, setIsAuthenticating] = useState(false);

    const handleAuth = async () => {
      setIsAuthenticating(true);
      try {
        const authenticatedUser = await authenticate();
        if (authenticatedUser) {
          console.log('Authenticated user:', authenticatedUser.fid);
          // Save to your backend
          await saveUserSession(authenticatedUser);
        }
      } catch (error) {
        console.error('Authentication failed:', error);
      } finally {
        setIsAuthenticating(false);
      }
    };

    if (user) {
      return (
        <div>
          <p>‚úÖ Authenticated as FID: {user.fid}</p>
          <button onClick={() => window.location.reload()}>
            Sign Out
          </button>
        </div>
      );
    }

    return (
      <button 
        onClick={handleAuth}
        disabled={isAuthenticating}
      >
        {isAuthenticating ? 'Authenticating...' : 'Sign In with Farcaster'}
      </button>
    );
  }
  ```

  ```tsx components/ProtectedFeature.tsx  
  import { useAuthenticate } from '@coinbase/onchainkit/minikit';

  export default function ProtectedFeature() {
    const { user, authenticate } = useAuthenticate();

    if (!user) {
      return (
        <div className="auth-required">
          <h3>Authentication Required</h3>
          <p>Please sign in to access this feature</p>
          <button onClick={authenticate}>
            Sign In with Farcaster
          </button>
        </div>
      );
    }

    return (
      <div className="protected-content">
        <h3>Welcome, {user.fid}!</h3>
        <p>This is a protected feature only available to authenticated users.</p>
      </div>
    );
  }
  ```
</RequestExample>

### Context vs Authentication

Use the right tool for the job:

```tsx components/SecurityExample.tsx
import { useAuthenticate, useMiniKit } from '@coinbase/onchainkit/minikit';

export default function SecurityExample() {
  const { user } = useAuthenticate(); // For security
  const { context } = useMiniKit();   // For UX 

  return (
    <div>
      {/* Safe: UX personalization with context */}
      {context.user.fid && (
        <p>Hi there, user {context.user.fid}!</p>
      )}
      
      {/* Safe: Security with authentication */}
      {user && (
        <SecureUserDashboard verifiedFid={user.fid} />
      )}
    </div>
  );
}
```

<Info>
  `useAuthenticate` provides cryptographic proof of user identity. Always verify signatures server-side for security-critical operations. Use `useMiniKit` context only for UX hints and analytics.
</Info>


# useComposeCast

> Open the cast composer with prefilled content

Defined in [@coinbase/onchainkit](https://github.com/coinbase/onchainkit)

<Info>
  Opens the native cast composer with prefilled text and embeds. Essential for viral growth and social sharing within Mini Apps.
</Info>

## Returns

<ResponseField name="composeCast" type="(params: ComposeCastParams) => void">
  Function that opens the cast composer with specified content.

  <Expandable title="ComposeCastParams properties">
    <ParamField body="text" type="string" required>
      The text content to prefill in the composer. Keep concise and engaging.
    </ParamField>

    <ParamField body="embeds" type="string[]">
      Array of URLs to embed in the cast. Usually includes your Mini App URL for sharing.
    </ParamField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```tsx Basic Text Sharing
  import { useComposeCast } from '@coinbase/onchainkit/minikit';

  export default function ShareButton() {
    const { composeCast } = useComposeCast();

    const handleShare = () => {
      composeCast({
        text: 'Just completed the daily puzzle! üß©'
      });
    };

    return (
      <button onClick={handleShare}>
        Share Achievement
      </button>
    );
  }
  ```

  ```tsx Share with App Embed
  import { useComposeCast } from '@coinbase/onchainkit/minikit';

  export default function ShareAppButton() {
    const { composeCast } = useComposeCast();

    const handleShareApp = () => {
      composeCast({
        text: 'Check out this amazing Mini App!',
        embeds: [window.location.href]
      });
    };

    return (
      <button onClick={handleShareApp}>
        Share Mini App
      </button>
    );
  }
  ```

  ```tsx Strategic Achievement Sharing
  import { useComposeCast } from '@coinbase/onchainkit/minikit';

  export default function GameComplete({ score, level }) {
    const { composeCast } = useComposeCast();

    const shareAchievement = () => {
      composeCast({
        text: `üéâ Just hit level ${level} with ${score} points!`,
        embeds: [
          window.location.href,
          'https://yourgame.com/achievements/' + achievementId
        ]
      });
    };

    const shareGameInvite = () => {
      composeCast({
        text: 'Want to challenge me? Try to beat my high score! üèÜ',
        embeds: [window.location.href]
      });
    };

    return (
      <div className="achievement-share">
        <h2>Congratulations! üéâ</h2>
        <p>Level {level} completed with {score} points</p>
        
        <div className="share-options">
          <button onClick={shareAchievement}>
            Share Achievement
          </button>
          <button onClick={shareGameInvite}>
            Challenge Friends
          </button>
        </div>
      </div>
    );
  }
  ```

  ```tsx Dynamic Content Sharing
  import { useComposeCast } from '@coinbase/onchainkit/minikit';
  import { useState } from 'react';

  export default function CustomShareDialog() {
    const { composeCast } = useComposeCast();
    const [shareText, setShareText] = useState('');

    const handleCustomShare = () => {
      if (!shareText.trim()) return;
      
      composeCast({
        text: shareText,
        embeds: [window.location.href]
      });
      
      // Clear after sharing
      setShareText('');
    };

    return (
      <div className="share-dialog">
        <textarea 
          value={shareText}
          onChange={(e) => setShareText(e.target.value)}
          placeholder="What would you like to share?"
          maxLength={280}
        />
        
        <div className="share-actions">
          <span>{280 - shareText.length} characters remaining</span>
          <button 
            onClick={handleCustomShare}
            disabled={!shareText.trim()}
          >
            Share Cast
          </button>
        </div>
      </div>
    );
  }
  ```
</RequestExample>

## Strategic Sharing Patterns

### Achievement Moments

Share at moments of user accomplishment:

```tsx examples/AchievementMoments.tsx
// After quiz completion
composeCast({
  text: "I'm a Ravenclaw! ü¶Ö What house are you?",
  embeds: [quizUrl]
});

// After NFT mint
composeCast({
  text: "Just minted my first collectible! üé®",
  embeds: [mintUrl, nftImageUrl]
});

// After game milestone
composeCast({
  text: "Finally beat level 50! This game is addictive üéÆ",
  embeds: [gameUrl]
});
```

### Viral Growth Mechanics

Design shares that encourage interaction:

```tsx examples/ViralGrowthMechanics.tsx
// Challenge pattern
composeCast({
  text: "Beat my time of 2:34 if you can! ‚è±Ô∏è",
  embeds: [challengeUrl]
});

// Social proof pattern  
composeCast({
  text: "Join 50,000+ players already playing!",
  embeds: [gameUrl]
});

// FOMO pattern
composeCast({
  text: "Limited edition drop ends in 2 hours! üî•",
  embeds: [dropUrl]
});
```

### Content Personalization

Customize shares based on user activity:

```tsx examples/ContentPersonalization.tsx
import { useMiniKit, useComposeCast } from '@coinbase/onchainkit/minikit';

export default function PersonalizedShare() {
  const { context } = useMiniKit();
  const { composeCast } = useComposeCast();
  
  const sharePersonalized = (achievement) => {
    const isNewUser = !context.client.added;
    
    const text = isNewUser 
      ? `Just discovered this amazing ${achievement.category} app!`
      : `Another ${achievement.type} completed! ${achievement.streak} day streak üî•`;
      
    composeCast({
      text,
      embeds: [window.location.href]
    });
  };

  return (
    <button onClick={() => sharePersonalized(userAchievement)}>
      Share Progress
    </button>
  );
}
```

## Best Practices

### Text Content

* **Keep it concise**: Farcaster has character limits
* **Include emotional context**: Use emojis and excitement
* **Add clear value**: Explain why others should care
* **Include call-to-action**: "Try it yourself", "Beat my score"

### Embed Strategy

* **Always include your app URL** for discoverability
* **Add relevant media**: Images, videos, other content
* **Test embed rendering**: Ensure metadata displays correctly

### Timing Optimization

* **Post-achievement**: When users feel accomplished
* **Social moments**: When friends are likely online
* **Value demonstration**: After showing app benefits
* **Avoid interruption**: Don't break user flow

<Warning>
  The composer opens in a native overlay or new window depending on the client. Users can modify the text before posting, so don't rely on exact text for tracking. Use URL parameters or unique embeds for attribution tracking.
</Warning>

<Info>
  `useComposeCast` is one of the most powerful hooks for viral growth. Strategic implementation of sharing at the right moments can significantly increase your Mini App's reach and user acquisition.
</Info>
